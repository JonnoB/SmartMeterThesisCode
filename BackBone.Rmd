---
title: "Metric backbone"
author: "Jonathan Bourne"
date: "27 September 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---

Stage 1: Identify lines that are definately semi-metric
Stage 2: Identify lines that are definately 2 hop metric
Stage 3: Identify remaining lines with breadth first search

```{r}
#stage 1 
Phase1SemiMetricRemoval <- function(s){
#Matrix of 1 triangle semi-metric edges
  #s: a distance matrix
      Smat<- col(s) 
      
      SemiMetric <- 1:ncol(s) %>%
      map(~{
        print(.x)
     #   TargetRows <- (.x+1):ncol(s)
     #LogicMat <- s[TargetRows,] + s[TargetRows,.x][Smat[TargetRows,]] < (s[TargetRows,.x])
     LogicMat <- s + s[,.x][Smat] < (s[,.x]) #slightly faster than using transpose it still takes ages though
 
     matrix(data = rowSums(LogicMat, na.rm = TRUE ) > 0, ncol = 1) #TRUE means semi-metric edge
      
      }) %>%
      do.call(cbind,.)
    
    
    s[SemiMetric] <- NA #change Semi-metric values to NA. This makes the further stages easier to manage
    
    s

}

```


```{r}
ShortestEdgeMetric <- function(s3){
  #begins phase two of finding the metric backbone
  #Takes in a matrix that has had the first round of semi-metric edges removed
  #Finds the shortest edge of each vertex and outputs a symmetric logical matrix
  #s3 the phase 1 complete distance matrix
  
ShortMetric <- 1:nrow(s3) %>% map_dbl(~which.min(s3[,.x])) #lowest value by column

MetricDF <-s3 #Create matrix of correct dimensions
MetricDF[] <- FALSE #Initially none of the edges are metric

Positions <- ShortMetric+(1:nrow(MetricDF)-1)*ncol(MetricDF) #find the shortest edge of each vertex

MetricDF[Positions] <- TRUE #The shortest edges are metric

MetricDF <- (MetricDF + t(MetricDF))>0 #the matrix is symmetric

MetricDF
}


TwoHopMetric <- function(s3, MetricDF){
  #Performs the second part of Phase two of creating the metric backbone
  #s3 is the phase 1 matrix
  #MetricDF if the shortest path metric matrix
  
  for(n in 1:ncol(s3)){  
 
  TargetNode <- n
  
  MetricVect <- which(MetricDF[,TargetNode]==T)
  
  TargetVect <- s3[,TargetNode]
  
  Min_to_beat <- 1:length(MetricVect) %>%
    map_dbl(~{
      MetricLength <- TargetVect[MetricVect[.x]] #metric length from target row.
  
      min((s3[, MetricVect[.x]]+ MetricLength)[-TargetNode], na.rm = TRUE) #finds the smallest length in the coressponding 
      ##node to target excluding the target node itself, aka no self-loops.    
      
    }) %>% min # The map outputs the shortest two hop of each metric edge, the min then finds the smallest of those.
  
  
  Edges2Check <- rank(TargetVect, na.last = "keep")[!MetricDF[,TargetNode]] #vector of edges to test excluding metric-edges
  
  OrderedEdgeDistance <- TargetVect[!MetricDF[,TargetNode]][order(TargetVect[Edges2Check], na.last = NA, decreasing = T)]
  
  #this while loop goes through each element and checks whether it is shorter then the minimum distance
  #The loop breaks when either condition is not met
  while(OrderedEdgeDistance[n] < Min_to_beat & n <= length(OrderedEdgeDistance)){ 
    
    #print(n);print(Min_to_beat)
    Min_to_beat <- OrderedEdgeDistance[n]
    
    #Add in the metric edges for column and row
    MetricDF[which(TargetVect == Min_to_beat), TargetNode] <- TRUE
    MetricDF[TargetNode, which(TargetVect == Min_to_beat)] <- TRUE
  
    } 
  
  }
  
  return(MetricDF)
  
}

Phase2TwoHopMetric <- function(s3){
  #Performs phase 2 of the metric backbone process.
  #Takes the output matrix of phase 1
  #s3: out put matrix of phase 1
  diag(s3) <- NA
  MetricDF <- ShortestEdgeMetric(s3) %>%
    TwoHopMetric(s3, .)
  
  return(MetricDF)
  
}

```

```{r}
MakeEdgList <- function(mat, VarName){
  #required as part of the phase 3 function
  
  melts3 <- mat*lower.tri(mat)
  melts3[ melts3 == 0 ] <- NA
  melts3 <- melts3 %>% 
    as.data.table(., keep.rownames= T) %>%
    melt(id.vars = "rn", 
       variable.name = "node2", 
       value = VarName, 
       na.rm = T)
  
}


Phase3MetricEdges <- function(s3, s4){
  #Removes the final semi-metric edges creating the metric backbone
  
  #variables throughout the function to save memory
  
  melts3 <- MakeEdgList(s3, "weight")
  melts4 <- MakeEdgList(s4, "Metric")

melts3 <- melts4[melts3, on = c("node2", "rn")][!is.na(weight)] %>%
  as.tibble %>% rename(node1 = rn) %>%
  mutate(edge_name = paste0(node1,"_", node2),
         Metric = ifelse(is.na(Metric), FALSE, TRUE),
         node2 = as.character(node2))

rm(melts4)

g <- graph_from_data_frame(melts3, directed = FALSE)

VertexID<- tibble(node = get.vertex.attribute(g, "name"), ID = 1:vcount(g))

Unlabled <- melts3 %>%
  filter(Metric ==FALSE) %>%
  left_join(., VertexID, by = c("node1" = "node")) %>%
  left_join(., VertexID, by = c("node2" = "node")) %>%
  rename(node1_ID = ID.x, node2_ID = ID.y)

rm(VertexID)

print("Perform Breadth first search across all unlabled nodes")

ShortestPath <-1:nrow(Unlabled) %>% map_dbl(~{
  distances(g, v = Unlabled$node1_ID[.x], to =Unlabled$node2_ID[.x] )
  })

Unlabled <- Unlabled %>%
  mutate(TrueShortest = ShortestPath,
         Metric = ifelse(all.equal(weight,TrueShortest), TRUE, FALSE))

print("Remove final Semi-metric edges")

melts3 <- melts3 %>%
  filter(Metric) %>%
  bind_rows(select(Unlabled, node1:edge_name))
  
return(melts3)

}

```


```{r}

```


```{r}

nodebase <-10

set.seed(876)
s <- matrix(rnorm(nodebase^2), nodebase) #%>% cor
 s <- s +abs(min(s))+0.001
 s[lower.tri(s)] = t(s)[lower.tri(s)]
 diag(s) <- 0
colnames(s) <- make.names(1:ncol(s))
rownames(s) <- make.names(1:ncol(s))
 
#s <-( 1-cor(s))  #square is used to exxagerate differences for testing small matrices
# s2<- s
# s2
 
s3 <- Phase1SemiMetricRemoval(s)
diag(s3)<- NA

s4 <- Phase2TwoHopMetric(s3)

test <- Phase3MetricEdges(s3, s4)

#diag(s4) <- NA
s4[1:10,1:10]

sum(s4, na.rm = T)#number of postively ID'd metric edges



melts3 <- MakeEdgList(s3, "weight")
melts4 <- MakeEdgList(s4, "Metric")

melts3 <- melts4[melts3, on = c("node2", "rn")][!is.na(weight)] %>%
  as.tibble %>% rename(node1 = rn) %>%
  mutate(edge_name = paste0(node1,"_", node2),
         Metric = ifelse(is.na(Metric), FALSE, TRUE))

g <- graph_from_data_frame(melts3, directed = FALSE)

VertexID<- tibble(node = get.vertex.attribute(g, "name"), ID = 1:vcount(g))

get.edge.attribute(g, "edge_name")

Unlabled <- melts3 %>%
  filter(Metric ==FALSE) %>%
  left_join(., VertexID, by = c("node1" = "node")) %>%
  left_join(., VertexID, by = c("node2" = "node")) %>%
  rename(node1_ID = ID.x, node2_ID = ID.y)

print("Perform Breadth first search across all unlabled nodes")

ShortestPath <-1:nrow(Unlabled) %>% map_dbl(~{
  distances(g, v = Unlabled$node1_ID[.x], to =Unlabled$node2_ID[.x] )
  })

Unlabled <- Unlabled %>%
  mutate(TrueShortest = ShortestPath,
         Metric = ifelse(all.equal(weight,TrueShortest), TRUE, FALSE))

print("Remove final Semi-metric edges")



ecount(g)
maxedge <- nodebase*(nodebase-1)/2
ecount(g)/(maxedge )

table(degree(g))

clus <-cluster_louvain(g)
colors <- rainbow(max(membership(clus)))
plot(g,vertex.color=colors[membership(clus)], vertex.label=NA, vertex.size = 3)

```


try with real data
```{r}
 
setwd("/home/jonno/Dropbox/MScThesis/DayTimeSeries")

datdat <- readRDS(list.files()[1]) %>% 
        as.tibble 
      
      cormat <- datdat[,2:ncol(datdat)] %>%
        as.matrix %>% cor(.)
      distmat <-1-cormat
      diag(cormat) <- NA
      
      min(distmat)
      max(distmat)
      
test <- Phase1SemiMetricRemoval(distmat)
test[is.na(test)] <- 0

gtest <- graph_from_adjacency_matrix(test, mode = "undirected", weighted = "weight", diag = FALSE) 


saveRDS(gtest, file.path(SavedData, "gtestSemiMetric1.rds"))

test<- readRDS(file.path(SavedData, "gtestSemiMetric1.rds"))

test2 <- as_adjacency_matrix(test, attr = "weight", sparse =0)

test <- test2 %>% as.data.table()  %>% melt()

ecount(gtest)
maxedgetest <- ncol(cormat)*(ncol(cormat)-1)/2
ecount(gtest)/(maxedgetest)
components(gtest)

fc <-cluster_louvain(gtest)

plot(gtest2)

colors <- rainbow(max(membership(fc)))
plot(gtest,vertex.color=colors[membership(fc)], vertex.label=NA, vertex.size = 3)

```


```{r}
apply_cosine_similarity <- function(df){
  cos.sim <- function(df, ix) 
  {
    A = df[ix[1],] 
    B = df[ix[2],]
    return( sum(A*B)/sqrt(sum(A^2)*sum(B^2)) )
  }   
  n <- nrow(df) 
  cmb <- expand.grid(i=1:n, j=1:n) 
  C <- matrix(apply(cmb,1,function(cmb){ cos.sim(df, cmb) }),n,n)
  C
}



dist2<- apply_cosine_similarity(t(as.matrix(datdat[, 2:100])))
dist2 <- cor(as.matrix(datdat[, 2:100]), method = "spearman")
dist1 <- cor((as.matrix(datdat[, 2:100])))

dist1[1:10, 1:10]
dist2[1:10, 1:10]

dist2 <- (1-dist2)

dist3 <- dist2



test2 <- Phase1SemiMetricRemoval(dist2)
test2[is.na(test2)] <- 0
diag(test2) <- 0

orderedheat(test2, order = "both", simMat = T, mergey = 1, mergex = 1, xblocks=1, yblocks=1)

gtest <- graph_from_adjacency_matrix(test2 , mode = "undirected", weighted = "weight", diag = FALSE) 


ecount(gtest)
maxedgetest <- ncol(dist2)*(ncol(dist2)-1)/2
ecount(gtest)/(maxedgetest)
components(gtest)
plot(gtest)
```


Find triangles with shorter edges

I am tring to find triangles in a distance matrix where a direct path is longer than going via another point.
The function works well for low values of n but is slow for larger values. 
I am trying to find out how to speed up this process. I have tried to use lineprof an click through to lower functions, but I don't understand what it is telling me. I don't know if there is some function in igraph that would help?

```{r}
library(purrr);library(magrittr); library(lineprof);library(shiny)

RemoveTri <- function(s){
      Smat<- col(s) 
      
      RemoveEdge <- 1:ncol(s) %>%
      map(~{
      print(.x)
        
        LogicMat <- s + s[,.x][Smat] < (s[,.x]) #I used this method to avoid transposing
        matrix(data = rowSums(LogicMat, na.rm = TRUE ) > 0, ncol = 1) #TRUE means edge can be removed
      
      }) %>%
      do.call(cbind,.)
    
    
    s[RemoveEdge] <- NA
    
    s

}

CreateData <- function(n, seed){
  set.seed(seed)
  s <- matrix(rnorm(n^2), n) #%>% cor
  s <- s +abs(min(s))+0.001
  s[lower.tri(s)] = t(s)[lower.tri(s)]
  diag(s) <- 0
  return(s)
 }


s <- CreateData(100, 876)
RemoveTri(s)

s2 <- CreateData(4000, 876)
RemoveTri(s2)


l <- lineprof(RemoveTri(s))
shine(l)
 
```

